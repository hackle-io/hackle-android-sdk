/**
 * Data Class Test Generation Script
 *
 * This script generates reflection-based tests for data classes to improve code coverage.
 * The generated tests are excluded from local development and only included in CI builds.
 *
 * Usage:
 *   Local:  ./gradlew test (generated tests excluded)
 *   CI:     ./gradlew generateDataClassTests test -Dtest.include.generated=true
 */

// Task to generate data class tests for coverage
tasks.register('generateDataClassTests') {
    description = 'Generate boilerplate tests for data classes to improve coverage using reflection'
    group = 'verification'

    doLast {
        def outputDir = file('build/generated-test/kotlin/io/hackle/android/internal/workspace')
        def outputFile = new File(outputDir, 'GeneratedDataClassTests.kt')

        outputDir.mkdirs()

        // Scan source files to find all top-level data classes automatically
        def dataClasses = []
        def srcDirs = android.sourceSets.main.java.srcDirs

        println "Scanning source directories for data classes..."

        srcDirs.each { srcDir ->
            if (!srcDir.exists()) return

            srcDir.eachFileRecurse { file ->
                if (!file.name.endsWith('.kt')) return
                if (file.path.contains('/test/')) return
                if (file.path.contains('/build/')) return
                if (file.path.contains('/generated/')) return

                try {
                    def content = file.text
                    def packageMatch = (content =~ /package\s+([\w.]+)/)
                    if (!packageMatch) return

                    def packageName = packageMatch[0][1]

                    // Find top-level data classes only (simpler and safer)
                    // Pattern: (internal )? data class ClassName
                    (content =~ /(?m)^(?:internal\s+)?data\s+class\s+(\w+)/).each { match ->
                        def className = match[1]
                        def fullName = "${packageName}.${className}"
                        if (!dataClasses.contains(fullName)) {
                            dataClasses << fullName
                        }
                    }
                } catch (Exception e) {
                    println "Warning: Failed to parse ${file.name}: ${e.message}"
                }
            }
        }

        println "Found ${dataClasses.size()} top-level data classes"
        dataClasses.take(10).each { println "  - ${it}" }
        if (dataClasses.size() > 10) {
            println "  ... and ${dataClasses.size() - 10} more"
        }

        // Generate imports for discovered packages
        def packages = dataClasses.collect { it.substring(0, it.lastIndexOf('.')) }.unique().sort()
        def imports = packages.collect { "import ${it}.*" }.join('\n')

        def testContent = """package io.hackle.android.internal.workspace

${imports}
import org.junit.Test
import strikt.api.expectThat
import strikt.assertions.*
import kotlin.reflect.KClass
import kotlin.reflect.KParameter
import kotlin.reflect.full.*

/**
 * Auto-generated reflection-based tests for data classes to improve coverage.
 * Generated by: generateDataClassTests Gradle task
 * DO NOT EDIT MANUALLY - This file is generated
 *
 * Automatically discovered ${dataClasses.size()} top-level data classes from source code.
 * Note: Nested data classes are not included in this scan for safety.
 */
class GeneratedDataClassTests {

    /**
     * Test all data classes for proper equals and hashCode implementation
     */
    @Test
    fun `all data classes - equals and hashCode contract`() {
        val testResults = mutableListOf<String>()

        findAllDataClasses().forEach { kClass ->
            try {
                val instance1 = createInstance(kClass)
                val instance2 = createInstance(kClass)

                // equals test
                if (instance1 != instance2) {
                    testResults.add("FAIL: \${kClass.simpleName} equals failed")
                }

                // hashCode test
                if (instance1.hashCode() != instance2.hashCode()) {
                    testResults.add("FAIL: \${kClass.simpleName} hashCode failed")
                }

                testResults.add("PASS: \${kClass.simpleName}")
            } catch (e: Exception) {
                testResults.add("SKIP: \${kClass.simpleName} - \${e.message}")
            }
        }

        println("Data class test results:")
        testResults.forEach { println("  \$it") }

        val failures = testResults.filter { it.startsWith("FAIL") }
        expectThat(failures).isEmpty()
    }

    /**
     * Test all data classes for proper copy function
     */
    @Test
    fun `all data classes - copy function works`() {
        val testResults = mutableListOf<String>()

        findAllDataClasses().forEach { kClass ->
            try {
                val instance = createInstance(kClass)
                val copyMethod = kClass.memberFunctions.find { it.name == "copy" }

                if (copyMethod != null) {
                    val copied = copyMethod.callBy(mapOf(copyMethod.parameters.first() to instance))

                    if (instance != copied) {
                        testResults.add("FAIL: \${kClass.simpleName} copy failed")
                    } else {
                        testResults.add("PASS: \${kClass.simpleName}")
                    }
                } else {
                    testResults.add("SKIP: \${kClass.simpleName} - no copy method")
                }
            } catch (e: Exception) {
                testResults.add("SKIP: \${kClass.simpleName} - \${e.message}")
            }
        }

        println("Copy function test results:")
        testResults.forEach { println("  \$it") }

        val failures = testResults.filter { it.startsWith("FAIL") }
        expectThat(failures).isEmpty()
    }

    /**
     * Test all data classes for proper toString implementation
     */
    @Test
    fun `all data classes - toString contains class name`() {
        val testResults = mutableListOf<String>()

        findAllDataClasses().forEach { kClass ->
            try {
                val instance = createInstance(kClass)
                val stringRep = instance.toString()

                if (!stringRep.contains(kClass.simpleName ?: "")) {
                    testResults.add("FAIL: \${kClass.simpleName} toString failed")
                } else {
                    testResults.add("PASS: \${kClass.simpleName}")
                }
            } catch (e: Exception) {
                testResults.add("SKIP: \${kClass.simpleName} - \${e.message}")
            }
        }

        println("ToString test results:")
        testResults.forEach { println("  \$it") }

        val failures = testResults.filter { it.startsWith("FAIL") }
        expectThat(failures).isEmpty()
    }

    private fun findAllDataClasses(): List<KClass<*>> {
        // Automatically discovered data classes from source code scan
        val classes = listOf(
${dataClasses.collect { "            ${it}::class" }.join(',\n')}
        )

        // Filter to ensure they are actually data classes
        return classes.filter { kClass ->
            try {
                kClass.isData
            } catch (e: Exception) {
                println("Warning: Failed to check if \${kClass.simpleName} is a data class: \${e.message}")
                false
            }
        }
    }

    private fun createInstance(kClass: KClass<*>): Any {
        val constructor = kClass.constructors.firstOrNull()
            ?: throw IllegalArgumentException("No constructor found for \${kClass.simpleName}")

        val args = constructor.parameters.associateWith { param ->
            getDefaultValue(param)
        }

        return constructor.callBy(args)
    }

    private fun getDefaultValue(param: KParameter): Any? {
        return when {
            param.isOptional -> null
            param.type.toString().contains("String") -> ""
            param.type.toString().contains("Int") && !param.type.toString().contains("?") -> 0
            param.type.toString().contains("Long") && !param.type.toString().contains("?") -> 0L
            param.type.toString().contains("Boolean") && !param.type.toString().contains("?") -> false
            param.type.toString().contains("Double") && !param.type.toString().contains("?") -> 0.0
            param.type.toString().contains("Float") && !param.type.toString().contains("?") -> 0.0f
            param.type.toString().contains("List") -> emptyList<Any>()
            param.type.toString().contains("Map") -> emptyMap<Any, Any>()
            param.type.toString().contains("Set") -> emptySet<Any>()
            param.type.isMarkedNullable -> null
            else -> null
        }
    }
}
"""

        outputFile.text = testContent
        println "Generated reflection-based data class tests: ${outputFile.absolutePath}"
    }
}

// Conditionally include generated tests in test source set
android.sourceSets {
    test {
        java {
            if (System.getProperty('test.include.generated') == 'true') {
                srcDir 'build/generated-test/kotlin'
            }
        }
    }
}
